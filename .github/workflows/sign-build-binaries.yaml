name: Build & Sign Autonomi (Windows, Keypair-only)

on:
  # Auto-run ONLY when a PR into main is merged (closed+merged)
  pull_request:
    types: [closed]
    branches: [ main ]

  # Manual trigger from Actions tab or API/CLI
  workflow_dispatch:
    inputs:
      bins:
        description: "Space-separated bin names to build & sign"
        required: false
        default: "antctl antnode evm-testnet"
      keypair_alias:
        description: "Override SM_KEYPAIR_ALIAS (optional)"
        required: false
        default: ""

jobs:
  build-and-sign-windows:
    # Ensure PR was merged (not just closed) OR allow manual runs
    if: github.event_name != 'pull_request' || github.event.pull_request.merged == true
    runs-on: windows-latest

    env:
      # DigiCert (from Secrets)
      SM_HOST: ${{ secrets.SM_HOST }}
      SM_API_KEY: ${{ secrets.SM_API_KEY }}
      SM_CLIENT_CERT_PASSWORD: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}
      SM_CLIENT_CERT_B64: ${{ secrets.SM_CLIENT_CERT_B64 }}

      # Use workflow input if provided; otherwise fall back to repo secret
      SM_KEYPAIR_ALIAS: ${{ (inputs.keypair_alias != '' && inputs.keypair_alias) || secrets.SM_KEYPAIR_ALIAS }}

      # Helpful logging (save to workspace for artifact upload if needed)
      SM_LOG_LEVEL: trace
      SM_LOG_FILE: ${{ github.workspace }}\smctl-signing.log

      # Binaries to build: use manual input if provided, else defaults
      AUTONOMI_BINS: ${{ (inputs.bins != '' && inputs.bins) || 'antctl antnode evm-testnet' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # --- Early validation of required secrets/values
      - name: Sanity-check required secrets/values
        shell: pwsh
        run: |
          $missing = @()
          if (-not $env:SM_HOST) { $missing += "SM_HOST" }
          if (-not $env:SM_API_KEY) { $missing += "SM_API_KEY" }
          if (-not "${{ secrets.SM_CLIENT_CERT_B64 }}") { $missing += "SM_CLIENT_CERT_B64" }
          if (-not $env:SM_CLIENT_CERT_PASSWORD) { $missing += "SM_CLIENT_CERT_PASSWORD" }
          if (-not $env:SM_KEYPAIR_ALIAS) { $missing += "SM_KEYPAIR_ALIAS (secret or manual input)" }
          if ($missing.Count -gt 0) {
            Write-Error ("Missing required secrets/inputs: " + ($missing -join ", "))
            exit 1
          }

      # --- Normalize & verify the base64 client certificate from Secrets
      - name: Prepare client certificate (normalize base64)
        id: prepare_cert
        shell: pwsh
        run: |
          $raw = @'
          ${{ secrets.SM_CLIENT_CERT_B64 }}
          '@
          # Strip whitespace/newlines
          $clean = ($raw -replace '\s','')
          if ([string]::IsNullOrWhiteSpace($clean)) {
            Write-Error "SM_CLIENT_CERT_B64 is empty after normalization."
            exit 1
          }
          try {
            # Validate base64 by attempting a decode (do not write to disk yet)
            [void][Convert]::FromBase64String($clean)
          } catch {
            Write-Error "SM_CLIENT_CERT_B64 is not valid Base64. Ensure you pasted a base64-encoded P12."
            exit 1
          }
          # Expose normalized value for the DigiCert action
          "sm_client_cert_b64=$clean" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      # --- Install DigiCert tools (installs smctl) and wire up the client cert
      - name: Setup DigiCert Software Trust Manager tools (installs smctl)
        uses: digicert/ssm-code-signing@v1
        with:
          sm_host: ${{ secrets.SM_HOST }}
          sm_api_key: ${{ secrets.SM_API_KEY }}
          sm_client_cert_b64: ${{ steps.prepare_cert.outputs.sm_client_cert_b64 }}
          sm_client_cert_password: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}

      - name: Verify smctl is available & auth works
        shell: pwsh
        run: |
          smctl -v
          smctl healthcheck
          Write-Host "DigiCert KeyLocker authenticated successfully"
          Write-Host "Log file location: $env:SM_LOG_FILE"

      # --- Install Rust & cache
      - name: Install Rust (stable)
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2
        with:
          cache-targets: true

      # --- Build requested Autonomi binaries
      - name: Build Autonomi binaries (release)
        shell: pwsh
        run: |
          $bins = $env:AUTONOMI_BINS.Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
          if (-not $bins -or $bins.Count -eq 0) {
            Write-Error "No binaries listed in AUTONOMI_BINS."
            exit 1
          }

          foreach ($b in $bins) {
            Write-Host "=== cargo build --release --bin $b ==="
            cargo build --release --bin $b
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Build failed for bin: $b"
              exit 1
            }
          }

          # Collect .exe outputs to a clean dist folder
          $dist = Join-Path $env:RUNNER_WORKSPACE "dist"
          if (Test-Path $dist) { Remove-Item $dist -Recurse -Force }
          New-Item -ItemType Directory -Path $dist -Force | Out-Null

          # Copy ONLY the explicitly listed bins
          $copiedCount = 0
          foreach ($b in $bins) {
            $exe = Join-Path "${{ github.workspace }}\target\release" "$b.exe"
            if (Test-Path $exe) {
              Copy-Item $exe $dist -Force
              $copiedCount++
              Write-Host "Copied: $b.exe"
            } else {
              Write-Error "Required exe not found: $exe"
              Write-Error "Ensure the binary name is correct and it was built successfully"
              exit 1
            }
          }

          if ($copiedCount -eq 0) {
            Write-Error "No .exe files found to sign. Check build output."
            exit 1
          }

          $found = Get-ChildItem $dist -Filter *.exe
          Write-Host "Executables staged for signing ($copiedCount files):"
          $found | ForEach-Object { Write-Host " - " $_.Name }

      # --- Sign all executables IN PLACE using Keypair alias (with parallel jobs)
      - name: Sign executables (Keypair alias, in-place)
        shell: pwsh
        run: |
          $dist = Join-Path $env:RUNNER_WORKSPACE "dist"
          $files = Get-ChildItem $dist -Filter *.exe

          # Create signing jobs for parallel execution
          $jobs = @()
          $maxParallel = 3  # Adjust based on DigiCert API rate limits

          foreach ($f in $files) {
            # Wait if we've hit the parallel limit
            while ((Get-Job -State Running).Count -ge $maxParallel) {
              Start-Sleep -Milliseconds 500
            }

            Write-Host "Starting signing job for: $($f.Name)"
            $job = Start-Job -ScriptBlock {
              param($filePath, $alias)
              $result = & smctl sign --keypair-alias "$alias" --input "$filePath" 2>&1
              if ($LASTEXITCODE -ne 0) {
                throw "Signing failed for $filePath : $result"
              }
              return "Successfully signed: $filePath"
            } -ArgumentList $f.FullName, $env:SM_KEYPAIR_ALIAS

            $jobs += $job
          }

          # Wait for all jobs and collect results
          $failed = @()
          foreach ($job in $jobs) {
            $result = Receive-Job -Job $job -Wait
            if ($job.State -eq 'Failed') {
              $failed += $job.ChildJobs[0].JobStateInfo.Reason.Message
            } else {
              Write-Host $result
            }
            Remove-Job -Job $job
          }

          if ($failed.Count -gt 0) {
            Write-Error ("Signing failed for the following files:`n" + ($failed -join "`n"))
            exit 1
          }

          Write-Host "All files signed successfully!"

      # --- Verify Authenticode signatures
      - name: Verify signatures (Authenticode)
        shell: pwsh
        run: |
          $dist = Join-Path $env:RUNNER_WORKSPACE "dist"
          $files = Get-ChildItem $dist -Filter *.exe
          $bad = @()
          $verified = 0

          foreach ($f in $files) {
            $sig = Get-AuthenticodeSignature $f.FullName
            "{0} -> {1}" -f $f.Name, $sig.Status | Write-Host

            if ($sig.Status -eq "Valid") {
              $verified++
              # Display certificate details for validation
              Write-Host "  Signer: $($sig.SignerCertificate.Subject)"
              Write-Host "  Issuer: $($sig.SignerCertificate.Issuer)"
            } else {
              $bad += $f.Name
            }
          }

          Write-Host "`nVerification Summary: $verified/$($files.Count) files verified successfully"

          if ($bad.Count -gt 0) {
            Write-Error ("Signature validation failed for:`n" + ($bad -join "`n"))
            exit 1
          }

      - name: Upload signed artifacts
        uses: actions/upload-artifact@v4
        with:
          name: autonomi-signed-exes
          path: ${{ runner.workspace }}\dist\*.exe
          if-no-files-found: error

      - name: Upload signing logs (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: signing-logs
          path: ${{ github.workspace }}\smctl-signing.log
          if-no-files-found: ignore
