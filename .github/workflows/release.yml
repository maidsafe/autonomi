name: release

on:
  workflow_dispatch:
    inputs:
      release-nat-detection:
        description: Release nat-detection binary
        type: boolean
        required: false
        default: false
      release-node-launchpad:
        description: Release node-launchpad binary
        type: boolean
        required: false
        default: false
      release-ant:
        description: Release ant binary
        type: boolean
        required: false
        default: false
      release-antnode:
        description: Release antnode binary
        type: boolean
        required: false
        default: false
      release-antctl:
        description: Release antctl binary
        type: boolean
        required: false
        default: false
      release-antctld:
        description: Release antctld binary
        type: boolean
        required: false
        default: false
      release-antnode-rpc-client:
        description: Release antnode_rpc_client binary
        type: boolean
        required: false
        default: false
      release-evm-testnet:
        description: Release evm-testnet binary
        type: boolean
        required: false
        default: false

env:
  WORKFLOW_URL: https://github.com/maidsafe/autonomi/actions/runs

jobs:
  build:
    if: ${{
        github.repository_owner == 'maidsafe' &&
        (github.ref == 'refs/heads/stable' || startsWith(github.ref, 'refs/heads/rc'))
      }}
    name: build
    environment: ${{ github.ref == 'refs/heads/stable' && 'stable' || 'release-candidate' }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: windows-latest
            target: x86_64-pc-windows-msvc
          - os: macos-latest
            target: x86_64-apple-darwin
          - os: macos-latest
            target: aarch64-apple-darwin
          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
          - os: ubuntu-latest
            target: arm-unknown-linux-musleabi
          - os: ubuntu-latest
            target: armv7-unknown-linux-musleabihf
          - os: ubuntu-latest
            target: aarch64-unknown-linux-musl
    steps:
      - uses: actions/checkout@v6
      - uses: dtolnay/rust-toolchain@stable
      - uses: cargo-bins/cargo-binstall@main
      - shell: bash
        run: cargo binstall --no-confirm just

      - name: build release artifacts
        shell: bash
        run: |
          export RELEASE_NAT_DETECTION="${{ inputs.release-nat-detection }}"
          export RELEASE_NODE_LAUNCHPAD="${{ inputs.release-node-launchpad }}"
          export RELEASE_ANT="${{ inputs.release-ant }}"
          export RELEASE_ANTNODE="${{ inputs.release-antnode }}"
          export RELEASE_ANTCTL="${{ inputs.release-antctl }}"
          export RELEASE_ANTCTLD="${{ inputs.release-antctld }}"
          export RELEASE_ANTNODE_RPC_CLIENT="${{ inputs.release-antnode-rpc-client }}"
          export RELEASE_EVM_TESTNET="${{ inputs.release-evm-testnet }}"

          just build-release-artifacts "${{ matrix.target }}"

      - name: Download previous binaries from S3
        shell: bash
        run: |
          arch="${{ matrix.target }}"

          get_version() {
            local crate_dir=$1
            grep "^version" < "$crate_dir/Cargo.toml" | head -n 1 | awk '{ print $3 }' | sed 's/"//g'
          }

          download_from_s3() {
            local bin_name=$1
            local crate_dir=$2
            local s3_bucket=$3

            version=$(get_version "$crate_dir")

            if [[ "$arch" == *"windows"* ]]; then
              archive_name="${bin_name}-${version}-${arch}.zip"
              binary_name="${bin_name}.exe"
            else
              archive_name="${bin_name}-${version}-${arch}.tar.gz"
              binary_name="${bin_name}"
            fi

            echo "Downloading ${archive_name} from S3..."
            if ! curl -f -L -o "${archive_name}" "https://${s3_bucket}.s3.eu-west-2.amazonaws.com/${archive_name}"; then
              echo "Failed to download ${archive_name}"
              return 1
            fi

            temp_dir=$(mktemp -d)
            if [[ "$arch" == *"windows"* ]]; then
              unzip -q "${archive_name}" -d "$temp_dir"
            else
              tar -xzf "${archive_name}" -C "$temp_dir"
            fi

            cp "$temp_dir/${binary_name}" "artifacts/${binary_name}"
            chmod +x "artifacts/${binary_name}"
            rm -rf "$temp_dir" "${archive_name}"

            echo "Downloaded ${bin_name} version ${version} from S3"
          }

          if [[ "${{ inputs.release-nat-detection }}" != "true" ]]; then
            download_from_s3 "nat-detection" "nat-detection" "nat-detection"
          fi

          if [[ "${{ inputs.release-node-launchpad }}" != "true" ]]; then
            download_from_s3 "node-launchpad" "node-launchpad" "node-launchpad"
          fi

          if [[ "${{ inputs.release-ant }}" != "true" ]]; then
            download_from_s3 "ant" "ant-cli" "autonomi-cli"
          fi

          if [[ "${{ inputs.release-antnode }}" != "true" ]]; then
            download_from_s3 "antnode" "ant-node" "antnode"
          fi

          if [[ "${{ inputs.release-antctl }}" != "true" ]]; then
            download_from_s3 "antctl" "ant-node-manager" "antctl"
          fi

          if [[ "${{ inputs.release-antctld }}" != "true" ]]; then
            download_from_s3 "antctld" "ant-node-manager" "antctl"
          fi

          if [[ "${{ inputs.release-antnode-rpc-client }}" != "true" ]]; then
            download_from_s3 "antnode_rpc_client" "ant-node-rpc-client" "antnode-rpc-client"
          fi

          if [[ "${{ inputs.release-evm-testnet }}" != "true" ]]; then
            download_from_s3 "evm-testnet" "evm-testnet" "evm-testnet"
          fi

      - uses: actions/upload-artifact@main
        with:
          name: autonomi-${{ matrix.target }}
          path: |
            artifacts
            !artifacts/.cargo-lock

  sign-windows-binaries:
    if: ${{
        github.repository_owner == 'maidsafe' &&
        (github.ref == 'refs/heads/stable' || startsWith(github.ref, 'refs/heads/rc'))
      }}
    name: sign windows binaries
    runs-on: windows-latest
    needs: [build]
    environment: ${{ github.ref == 'refs/heads/stable' && 'stable' || 'release-candidate' }}
    env:
      RELEASE_ANT: ${{ inputs.release-ant }}
      RELEASE_ANTNODE: ${{ inputs.release-antnode }}
      RELEASE_ANTCTL: ${{ inputs.release-antctl }}
      RELEASE_ANTCTLD: ${{ inputs.release-antctld }}
      RELEASE_ANTNODE_RPC_CLIENT: ${{ inputs.release-antnode-rpc-client }}
      RELEASE_EVM_TESTNET: ${{ inputs.release-evm-testnet }}
      RELEASE_NAT_DETECTION: ${{ inputs.release-nat-detection }}
      RELEASE_NODE_LAUNCHPAD: ${{ inputs.release-node-launchpad }}
      SM_HOST: ${{ secrets.SM_HOST }}
      SM_API_KEY: ${{ secrets.SM_API_KEY }}
      SM_CLIENT_CERT_PASSWORD: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}
      SM_KEYPAIR_ALIAS: ${{ secrets.SM_KEYPAIR_ALIAS }}
      SM_LOG_LEVEL: trace
      SM_LOG_FILE: ${{ github.workspace }}\smctl-signing.log
    steps:
      - uses: actions/checkout@v6

      - uses: actions/download-artifact@master
        with:
          name: autonomi-x86_64-pc-windows-msvc
          path: artifacts/x86_64-pc-windows-msvc/release

      - name: Create client certificate file from base64
        id: prepare_cert
        shell: pwsh
        run: |
          $raw = @'
          ${{ secrets.SM_CLIENT_CERT_B64 }}
          '@

          $clean = ($raw -replace '\s','')

          if ([string]::IsNullOrWhiteSpace($clean)) {
            Write-Error "SM_CLIENT_CERT_B64 is empty after normalization."
            exit 1
          }

          try {
            $certBytes = [Convert]::FromBase64String($clean)
          } catch {
            Write-Error "SM_CLIENT_CERT_B64 is not valid Base64. Ensure you pasted a base64-encoded P12."
            exit 1
          }

          $certPath = Join-Path $env:RUNNER_TEMP "Certificate.p12"
          [System.IO.File]::WriteAllBytes($certPath, $certBytes)

          if (-not (Test-Path $certPath)) {
            Write-Error "Failed to create certificate file at: $certPath"
            exit 1
          }

          "SM_CLIENT_CERT_FILE=$certPath" | Out-File -FilePath $env:GITHUB_ENV -Append

          "cert_path=$certPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "sm_client_cert_b64=$clean" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Setup DigiCert Software Trust Manager tools (installs smctl)
        uses: digicert/ssm-code-signing@v1.1.1
        with:
          sm_host: ${{ secrets.SM_HOST }}
          sm_api_key: ${{ secrets.SM_API_KEY }}
          sm_client_cert_b64: ${{ steps.prepare_cert.outputs.sm_client_cert_b64 }}
          sm_client_cert_password: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}

      - name: Verify smctl installation and certificate access
        shell: pwsh
        run: |
          smctl -v
          smctl healthcheck
          smctl keypair ls

      - name: Sign Windows executables
        shell: pwsh
        run: |
          $artifactsPath = "artifacts\x86_64-pc-windows-msvc\release"
          $allFiles = Get-ChildItem $artifactsPath -Filter *.exe -Recurse

          # Define which binaries should be signed based on build flags
          $binaryMap = @{
            "nat-detection.exe" = $env:RELEASE_NAT_DETECTION
            "node-launchpad.exe" = $env:RELEASE_NODE_LAUNCHPAD
            "ant.exe" = $env:RELEASE_ANT
            "antnode.exe" = $env:RELEASE_ANTNODE
            "antctl.exe" = $env:RELEASE_ANTCTL
            "antctld.exe" = $env:RELEASE_ANTCTLD
            "antnode_rpc_client.exe" = $env:RELEASE_ANTNODE_RPC_CLIENT
            "evm-testnet.exe" = $env:RELEASE_EVM_TESTNET
          }

          # Filter files to only those that were built in this run
          $files = $allFiles | Where-Object {
            $fileName = $_.Name
            $shouldBuild = $binaryMap[$fileName]
            if ($shouldBuild -eq "true") {
              return $true
            }
            Write-Host "Skipping $fileName (not built in this run)"
            return $false
          }

          if ($files.Count -eq 0) {
            Write-Host "No executables to sign (none were built in this run)"
            exit 0
          }

          Write-Host "Found $($files.Count) executable(s) to sign:"
          $files | ForEach-Object { Write-Host "  - $($_.Name)" }
          Write-Host ""

          $smHostValue = $env:SM_HOST
          $smApiKey = $env:SM_API_KEY
          $smClientCertFile = $env:SM_CLIENT_CERT_FILE
          $smClientCertPassword = $env:SM_CLIENT_CERT_PASSWORD
          $smKeypairAlias = $env:SM_KEYPAIR_ALIAS
          $smLogLevel = $env:SM_LOG_LEVEL
          $smLogFile = $env:SM_LOG_FILE

          $jobs = @()
          $maxParallel = 3

          foreach ($f in $files) {
            # Wait if we've hit the parallel limit
            while ((Get-Job -State Running).Count -ge $maxParallel) {
              Start-Sleep -Milliseconds 500
            }

            Write-Host "Starting signing job for: $($f.Name)"
            $job = Start-Job -ScriptBlock {
              param($filePath, $alias, $smHostValue, $apiKey, $certFile, $certPassword, $logLevel, $logFile)

              $env:SM_HOST = $smHostValue
              $env:SM_API_KEY = $apiKey
              $env:SM_CLIENT_CERT_FILE = $certFile
              $env:SM_CLIENT_CERT_PASSWORD = $certPassword
              $env:SM_KEYPAIR_ALIAS = $alias
              $env:SM_LOG_LEVEL = $logLevel
              $env:SM_LOG_FILE = $logFile

              $result = & smctl sign --keypair-alias "$alias" --input "$filePath" 2>&1
              if ($LASTEXITCODE -ne 0) {
                throw "Signing failed for $filePath : $result"
              }
              return "Successfully signed: $filePath"
            } -ArgumentList $f.FullName, $smKeypairAlias, $smHostValue, $smApiKey, $smClientCertFile, $smClientCertPassword, $smLogLevel, $smLogFile

            $jobs += $job
          }

          $failed = @()
          foreach ($job in $jobs) {
            $result = Receive-Job -Job $job -Wait
            if ($job.State -eq 'Failed') {
              $failed += $job.ChildJobs[0].JobStateInfo.Reason.Message
            } else {
              Write-Host $result
            }
            Remove-Job -Job $job
          }

          if ($failed.Count -gt 0) {
            Write-Error ("Signing failed for the following files:`n" + ($failed -join "`n"))
            exit 1
          }

          Write-Host ""
          Write-Host "All files signed successfully!"

      - name: Verify signatures (Authenticode)
        shell: pwsh
        run: |
          $artifactsPath = "artifacts\x86_64-pc-windows-msvc\release"
          $allFiles = Get-ChildItem $artifactsPath -Filter *.exe -Recurse

          # Define which binaries should be verified based on build flags
          $binaryMap = @{
            "nat-detection.exe" = $env:RELEASE_NAT_DETECTION
            "node-launchpad.exe" = $env:RELEASE_NODE_LAUNCHPAD
            "ant.exe" = $env:RELEASE_ANT
            "antnode.exe" = $env:RELEASE_ANTNODE
            "antctl.exe" = $env:RELEASE_ANTCTL
            "antctld.exe" = $env:RELEASE_ANTCTLD
            "antnode_rpc_client.exe" = $env:RELEASE_ANTNODE_RPC_CLIENT
            "evm-testnet.exe" = $env:RELEASE_EVM_TESTNET
          }

          # Filter files to only those that were built and signed in this run
          $files = $allFiles | Where-Object {
            $fileName = $_.Name
            $shouldBuild = $binaryMap[$fileName]
            return $shouldBuild -eq "true"
          }

          if ($files.Count -eq 0) {
            Write-Host "No executables to verify (none were built in this run)"
            exit 0
          }

          $bad = @()
          $verified = 0

          foreach ($f in $files) {
            $sig = Get-AuthenticodeSignature $f.FullName
            "{0} -> {1}" -f $f.Name, $sig.Status | Write-Host

            if ($sig.Status -eq "Valid") {
              $verified++
              Write-Host "  Signer: $($sig.SignerCertificate.Subject)"
              Write-Host "  Issuer: $($sig.SignerCertificate.Issuer)"
            } else {
              $bad += $f.Name
            }
          }

          Write-Host "`nVerification Summary: $verified/$($files.Count) files verified successfully"

          if ($bad.Count -gt 0) {
            Write-Error ("Signature validation failed for:`n" + ($bad -join "`n"))
            exit 1
          }

      - uses: actions/upload-artifact@v6
        with:
          name: autonomi-x86_64-pc-windows-msvc-signed
          path: artifacts/x86_64-pc-windows-msvc/release

      - name: Upload signing logs (on failure)
        if: failure()
        uses: actions/upload-artifact@v6
        with:
          name: release-signing-logs
          path: ${{ github.workspace }}\smctl-signing.log
          if-no-files-found: ignore

  sign-macos-pkg-x86_64:
    if: ${{
        github.repository_owner == 'maidsafe' &&
        (github.ref == 'refs/heads/stable' || startsWith(github.ref, 'refs/heads/rc'))
      }}
    name: sign macos pkg (x86_64)
    needs: [build]
    uses: ./.github/workflows/build-macos-pkg.yml
    with:
      arch: x86_64-apple-darwin
    secrets:
      APPLE_APPLICATION_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_APPLICATION_CERTIFICATE_P12_BASE64 }}
      APPLE_APPLICATION_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_APPLICATION_CERTIFICATE_PASSWORD }}
      APPLE_INSTALLER_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_INSTALLER_CERTIFICATE_P12_BASE64 }}
      APPLE_INSTALLER_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_INSTALLER_CERTIFICATE_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_NOTARIZATION_PASSWORD: ${{ secrets.APPLE_NOTARIZATION_PASSWORD }}

  sign-macos-pkg-aarch64:
    if: ${{
        github.repository_owner == 'maidsafe' &&
        (github.ref == 'refs/heads/stable' || startsWith(github.ref, 'refs/heads/rc'))
      }}
    name: sign macos pkg (aarch64)
    needs: [build]
    uses: ./.github/workflows/build-macos-pkg.yml
    with:
      arch: aarch64-apple-darwin
    secrets:
      APPLE_APPLICATION_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_APPLICATION_CERTIFICATE_P12_BASE64 }}
      APPLE_APPLICATION_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_APPLICATION_CERTIFICATE_PASSWORD }}
      APPLE_INSTALLER_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_INSTALLER_CERTIFICATE_P12_BASE64 }}
      APPLE_INSTALLER_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_INSTALLER_CERTIFICATE_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_NOTARIZATION_PASSWORD: ${{ secrets.APPLE_NOTARIZATION_PASSWORD }}

  sign-macos-app-x86_64:
    if: ${{
        github.repository_owner == 'maidsafe' &&
        (github.ref == 'refs/heads/stable' || startsWith(github.ref, 'refs/heads/rc'))
      }}
    name: sign macos app (x86_64)
    needs: [build]
    uses: ./.github/workflows/build-macos-app.yml
    with:
      arch: x86_64-apple-darwin
    secrets:
      APPLE_APPLICATION_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_APPLICATION_CERTIFICATE_P12_BASE64 }}
      APPLE_APPLICATION_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_APPLICATION_CERTIFICATE_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_NOTARIZATION_PASSWORD: ${{ secrets.APPLE_NOTARIZATION_PASSWORD }}

  sign-macos-app-aarch64:
    if: ${{
        github.repository_owner == 'maidsafe' &&
        (github.ref == 'refs/heads/stable' || startsWith(github.ref, 'refs/heads/rc'))
      }}
    name: sign macos app (aarch64)
    needs: [build]
    uses: ./.github/workflows/build-macos-app.yml
    with:
      arch: aarch64-apple-darwin
    secrets:
      APPLE_APPLICATION_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_APPLICATION_CERTIFICATE_P12_BASE64 }}
      APPLE_APPLICATION_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_APPLICATION_CERTIFICATE_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_NOTARIZATION_PASSWORD: ${{ secrets.APPLE_NOTARIZATION_PASSWORD }}

  build-windows-msi:
    if: ${{
        github.repository_owner == 'maidsafe' &&
        (github.ref == 'refs/heads/stable' || startsWith(github.ref, 'refs/heads/rc'))
      }}
    name: build windows msi
    needs: [sign-windows-binaries]
    uses: ./.github/workflows/build-windows-msi.yml
    secrets:
      SM_HOST: ${{ secrets.SM_HOST }}
      SM_API_KEY: ${{ secrets.SM_API_KEY }}
      SM_CLIENT_CERT_B64: ${{ secrets.SM_CLIENT_CERT_B64 }}
      SM_CLIENT_CERT_PASSWORD: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}
      SM_KEYPAIR_ALIAS: ${{ secrets.SM_KEYPAIR_ALIAS }}

  build-windows-msix:
    if: ${{
        github.repository_owner == 'maidsafe' &&
        (github.ref == 'refs/heads/stable' || startsWith(github.ref, 'refs/heads/rc'))
      }}
    name: build windows msix
    needs: [sign-windows-binaries]
    uses: ./.github/workflows/build-windows-msix.yml
    secrets:
      SM_HOST: ${{ secrets.SM_HOST }}
      SM_API_KEY: ${{ secrets.SM_API_KEY }}
      SM_CLIENT_CERT_B64: ${{ secrets.SM_CLIENT_CERT_B64 }}
      SM_CLIENT_CERT_PASSWORD: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}
      SM_KEYPAIR_ALIAS: ${{ secrets.SM_KEYPAIR_ALIAS }}

  build-linux-deb:
    if: ${{
        github.repository_owner == 'maidsafe' &&
        (github.ref == 'refs/heads/stable' || startsWith(github.ref, 'refs/heads/rc'))
      }}
    name: build linux deb
    needs: [build]
    uses: ./.github/workflows/build-linux-deb.yml
    secrets:
      GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
      GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

  build-linux-rpm:
    if: ${{
        github.repository_owner == 'maidsafe' &&
        (github.ref == 'refs/heads/stable' || startsWith(github.ref, 'refs/heads/rc'))
      }}
    name: build linux rpm
    needs: [build]
    uses: ./.github/workflows/build-linux-rpm.yml
    secrets:
      GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
      GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

  s3-release:
    if: ${{
        github.repository_owner == 'maidsafe' &&
        (github.ref == 'refs/heads/stable' || startsWith(github.ref, 'refs/heads/rc'))
      }}
    name: s3 release
    runs-on: ubuntu-latest
    needs: [build, sign-windows-binaries]
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.S3_DEPLOY_AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.S3_DEPLOY_AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: eu-west-2
    steps:
      - uses: actions/checkout@v6
      - uses: actions/download-artifact@master
        with:
          name: autonomi-x86_64-pc-windows-msvc
          path: artifacts/x86_64-pc-windows-msvc/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-x86_64-pc-windows-msvc-signed
          path: artifacts/x86_64-pc-windows-msvc-signed/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-x86_64-unknown-linux-musl
          path: artifacts/x86_64-unknown-linux-musl/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-x86_64-apple-darwin
          path: artifacts/x86_64-apple-darwin/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-aarch64-apple-darwin
          path: artifacts/aarch64-apple-darwin/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-arm-unknown-linux-musleabi
          path: artifacts/arm-unknown-linux-musleabi/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-armv7-unknown-linux-musleabihf
          path: artifacts/armv7-unknown-linux-musleabihf/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-aarch64-unknown-linux-musl
          path: artifacts/aarch64-unknown-linux-musl/release

      - uses: cargo-bins/cargo-binstall@main
      - name: install just
        shell: bash
        run: cargo binstall --no-confirm just

      - name: replace unsigned Windows binaries with signed ones
        shell: bash
        run: |
          # Replace only the binaries that were built and signed in this run
          binaries=(
            "nat-detection:${{ inputs.release-nat-detection }}"
            "node-launchpad:${{ inputs.release-node-launchpad }}"
            "ant:${{ inputs.release-ant }}"
            "antnode:${{ inputs.release-antnode }}"
            "antctl:${{ inputs.release-antctl }}"
            "antctld:${{ inputs.release-antctld }}"
            "antnode_rpc_client:${{ inputs.release-antnode-rpc-client }}"
            "evm-testnet:${{ inputs.release-evm-testnet }}"
          )

          for entry in "${binaries[@]}"; do
            binary="${entry%%:*}"
            should_build="${entry##*:}"

            if [[ "$should_build" == "true" ]]; then
              echo "Replacing ${binary}.exe with signed version"
              if [[ -f "artifacts/x86_64-pc-windows-msvc-signed/release/${binary}.exe" ]]; then
                cp "artifacts/x86_64-pc-windows-msvc-signed/release/${binary}.exe" \
                   "artifacts/x86_64-pc-windows-msvc/release/${binary}.exe"
              else
                echo "Signed binary ${binary}.exe not found"
                exit 1
              fi
            else
              echo "Skipping ${binary}.exe (not built in this run)"
            fi
          done

      - name: upload binaries to S3
        shell: bash
        run: |
          # Package versioned assets as tar.gz and zip archives, and upload them to S3.
          #
          # This is done before publishing because the node manager relies on these binaries
          # existing after the new version of the `sn_node` crate is published. If these binaries
          # were uploaded after the publishing process, there could be a significant gap between the
          # new version of `sn_node` being published and the new binaries being available for
          # download. This could cause errors if node manager users ran the `upgrade` command,
          # because the process gets the latest version from `crates.io` then downloads the binaries
          # from S3, using that version number. Uploading the binaries to S3 before publishing
          # ensures that they will exist after the new crate has been published.
          just package-all-bins
          just upload-all-packaged-bins-to-s3

  github-release:
    if: ${{
        github.repository_owner == 'maidsafe' &&
        (github.ref == 'refs/heads/stable' || startsWith(github.ref, 'refs/heads/rc'))
      }}
    name: github release
    runs-on: ubuntu-latest
    needs: [build, sign-windows-binaries, sign-macos-pkg-x86_64, sign-macos-pkg-aarch64, sign-macos-app-x86_64, sign-macos-app-aarch64, build-windows-msi, build-windows-msix, build-linux-deb, build-linux-rpm, s3-release]
    steps:
      - uses: actions/checkout@v6
      - uses: actions/download-artifact@master
        with:
          name: autonomi-x86_64-pc-windows-msvc
          path: artifacts/x86_64-pc-windows-msvc/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-x86_64-pc-windows-msvc-signed
          path: artifacts/x86_64-pc-windows-msvc-signed/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-x86_64-unknown-linux-musl
          path: artifacts/x86_64-unknown-linux-musl/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-x86_64-apple-darwin
          path: artifacts/x86_64-apple-darwin/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-aarch64-apple-darwin
          path: artifacts/aarch64-apple-darwin/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-arm-unknown-linux-musleabi
          path: artifacts/arm-unknown-linux-musleabi/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-armv7-unknown-linux-musleabihf
          path: artifacts/armv7-unknown-linux-musleabihf/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-aarch64-unknown-linux-musl
          path: artifacts/aarch64-unknown-linux-musl/release
      - uses: actions/download-artifact@master
        with:
          name: autonomi-pkg-x86_64-apple-darwin
          path: pkg-artifacts
      - uses: actions/download-artifact@master
        with:
          name: autonomi-pkg-aarch64-apple-darwin
          path: pkg-artifacts
      - uses: actions/download-artifact@master
        with:
          name: node-launchpad-dmg-x86_64-apple-darwin
          path: dmg-artifacts
      - uses: actions/download-artifact@master
        with:
          name: node-launchpad-dmg-aarch64-apple-darwin
          path: dmg-artifacts
      - uses: actions/download-artifact@master
        with:
          name: autonomi-msi-x86_64-pc-windows-msvc
          path: msi-artifacts
      - uses: actions/download-artifact@master
        with:
          name: node-launchpad-msix-x86_64-pc-windows-msvc
          path: msix-artifacts
      - uses: actions/download-artifact@v4
        with:
          name: autonomi-deb-x86_64-unknown-linux-musl
          path: deb-artifacts
      - uses: actions/download-artifact@v4
        with:
          name: autonomi-deb-aarch64-unknown-linux-musl
          path: deb-artifacts
      - uses: actions/download-artifact@v4
        with:
          name: autonomi-deb-armv7-unknown-linux-musleabihf
          path: deb-artifacts
      - uses: actions/download-artifact@v4
        with:
          name: autonomi-deb-arm-unknown-linux-musleabi
          path: deb-artifacts
      - uses: actions/download-artifact@v4
        with:
          name: autonomi-rpm-x86_64-unknown-linux-musl
          path: rpm-artifacts
      - uses: actions/download-artifact@v4
        with:
          name: autonomi-rpm-aarch64-unknown-linux-musl
          path: rpm-artifacts
      - uses: actions/download-artifact@v4
        with:
          name: autonomi-rpm-armv7-unknown-linux-musleabihf
          path: rpm-artifacts
      - uses: actions/download-artifact@v4
        with:
          name: autonomi-rpm-arm-unknown-linux-musleabi
          path: rpm-artifacts

      - uses: cargo-bins/cargo-binstall@main
      - name: install just
        shell: bash
        run: cargo binstall --no-confirm just

      - name: replace unsigned Windows binaries with signed ones
        shell: bash
        run: |
          # Replace only the binaries that were built and signed in this run
          binaries=(
            "nat-detection:${{ inputs.release-nat-detection }}"
            "node-launchpad:${{ inputs.release-node-launchpad }}"
            "ant:${{ inputs.release-ant }}"
            "antnode:${{ inputs.release-antnode }}"
            "antctl:${{ inputs.release-antctl }}"
            "antctld:${{ inputs.release-antctld }}"
            "antnode_rpc_client:${{ inputs.release-antnode-rpc-client }}"
            "evm-testnet:${{ inputs.release-evm-testnet }}"
          )

          for entry in "${binaries[@]}"; do
            binary="${entry%%:*}"
            should_build="${entry##*:}"

            if [[ "$should_build" == "true" ]]; then
              echo "Replacing ${binary}.exe with signed version"
              if [[ -f "artifacts/x86_64-pc-windows-msvc-signed/release/${binary}.exe" ]]; then
                cp "artifacts/x86_64-pc-windows-msvc-signed/release/${binary}.exe" \
                   "artifacts/x86_64-pc-windows-msvc/release/${binary}.exe"
              else
                echo "Warning: Signed binary ${binary}.exe not found"
              fi
            else
              echo "Skipping ${binary}.exe (not built in this run)"
            fi
          done

      - name: set stable release prefix
        if: ${{ github.ref == 'refs/heads/stable' }}
        run: |
          echo "RELEASE_PREFIX=stable" >> $GITHUB_ENV

      - name: set rc release prefix
        if: ${{ startsWith(github.ref, 'refs/heads/rc') }}
        run: |
          echo "RELEASE_PREFIX=rc" >> $GITHUB_ENV

      - name: set package version
        shell: bash
        run: |
          release_year=$(grep 'release-year:' release-cycle-info | awk '{print $2}')
          release_month=$(grep 'release-month:' release-cycle-info | awk '{print $2}')
          release_cycle=$(grep 'release-cycle:' release-cycle-info | awk '{print $2}')
          release_cycle_counter=$(grep 'release-cycle-counter:' release-cycle-info | awk '{print $2}')
          version="$release_year.$release_month.$release_cycle.$release_cycle_counter"
          echo "PACKAGE_VERSION=$version" >> $GITHUB_ENV

      - name: package release artifacts
        shell: bash
        run: just package-all-architectures

      - name: generate release description
        shell: bash
        run: |
          {
            just build-binary-versions
            just build-artifact-hashes
            echo ""
            echo "## Installation Options"
            echo ""
            echo "### macOS CLI Suite"
            echo ""
            echo "Install \`ant\`, \`antnode\`, and \`antctl\` using the signed and notarized pkg installer."
            echo ""
            echo "Download the appropriate pkg file for your Mac:"
            echo "- **Apple Silicon (M1/M2/M3):** \`${{ env.PACKAGE_VERSION }}.autonomi.aarch64-apple-darwin.pkg\`"
            echo "- **Intel:** \`${{ env.PACKAGE_VERSION }}.autonomi.x86_64-apple-darwin.pkg\`"
            echo ""
            echo "Double-click the downloaded file and follow the installation prompts."
            echo "The binaries will be installed to \`/usr/local/bin\`."
            echo ""
            echo "Verify the installation:"
            echo "\`\`\`bash"
            echo "ant --version"
            echo "antnode --version"
            echo "antctl --version"
            echo "\`\`\`"
            echo ""
            echo "### macOS Node Launchpad App"
            echo ""
            echo "Node Launchpad is a TUI application for managing Autonomi nodes."
            echo ""
            echo "Download the appropriate DMG file for your Mac:"
            echo "- **Apple Silicon (M1/M2/M3):** \`${{ env.PACKAGE_VERSION }}.node-launchpad.aarch64-apple-darwin.dmg\`"
            echo "- **Intel:** \`${{ env.PACKAGE_VERSION }}.node-launchpad.x86_64-apple-darwin.dmg\`"
            echo ""
            echo "Open the DMG and drag Node Launchpad to your Applications folder."
            echo "The app will open Terminal and run the Node Launchpad TUI."
            echo ""
            echo "### Windows CLI Suite"
            echo ""
            echo "Install \`ant\`, \`antnode\`, and \`antctl\` using the signed MSI installer."
            echo ""
            echo "Download: \`${{ env.PACKAGE_VERSION }}.autonomi.x86_64-pc-windows-msvc.msi\`"
            echo ""
            echo "Double-click the downloaded file and follow the installation prompts."
            echo "The binaries will be installed to \`C:\\Program Files\\Autonomi\\\` and added to your PATH."
            echo ""
            echo "Verify the installation (open a new Command Prompt or PowerShell):"
            echo "\`\`\`powershell"
            echo "ant --version"
            echo "antnode --version"
            echo "antctl --version"
            echo "\`\`\`"
            echo ""
            echo "### Windows Node Launchpad App"
            echo ""
            echo "Node Launchpad is a TUI application for managing Autonomi nodes."
            echo ""
            echo "**Option 1: Direct MSIX Install**"
            echo ""
            echo "Download: \`${{ env.PACKAGE_VERSION }}.node-launchpad.x86_64-pc-windows-msvc.msix\`"
            echo ""
            echo "Double-click the downloaded file to install. The app will appear in your Start Menu."
            echo ""
            echo "**Option 2: Install with Auto-Updates (Recommended)**"
            echo ""
            echo "Download: \`${{ env.PACKAGE_VERSION }}.node-launchpad.x86_64-pc-windows-msvc.appinstaller\`"
            echo ""
            echo "Double-click the .appinstaller file. This will install the app and enable automatic updates."
            echo "When a new version is released, you'll be prompted to update on app launch."
            echo ""
            echo "After installation, you can run Node Launchpad from the Start Menu or by typing \`node-launchpad.exe\` in any terminal."
            echo ""
            echo "### Linux CLI Suite (Debian/Ubuntu)"
            echo ""
            echo "Install \`ant\`, \`antnode\`, and \`antctl\` using the signed deb package."
            echo ""
            echo "Download the appropriate deb file for your architecture:"
            echo "- **x86_64 (AMD64):** \`${{ env.PACKAGE_VERSION }}.autonomi.x86_64-unknown-linux-musl.deb\`"
            echo "- **ARM64 (aarch64):** \`${{ env.PACKAGE_VERSION }}.autonomi.aarch64-unknown-linux-musl.deb\`"
            echo "- **ARMv7 (armhf):** \`${{ env.PACKAGE_VERSION }}.autonomi.armv7-unknown-linux-musleabihf.deb\`"
            echo "- **ARM (armel):** \`${{ env.PACKAGE_VERSION }}.autonomi.arm-unknown-linux-musleabi.deb\`"
            echo ""
            echo "**Import the GPG signing key (first time only):**"
            echo "\`\`\`bash"
            echo "curl -fsSL https://github.com/maidsafe/autonomi/raw/main/resources/keys/autonomi-signing-key.asc | sudo gpg --dearmor -o /usr/share/keyrings/autonomi-archive-keyring.gpg"
            echo "\`\`\`"
            echo ""
            echo "**Install the package:**"
            echo "\`\`\`bash"
            echo "sudo dpkg -i ${{ env.PACKAGE_VERSION }}.autonomi.x86_64-unknown-linux-musl.deb"
            echo "\`\`\`"
            echo ""
            echo "**Verify the signature (optional):**"
            echo "\`\`\`bash"
            echo "gpg --verify ${{ env.PACKAGE_VERSION }}.autonomi.x86_64-unknown-linux-musl.deb.asc ${{ env.PACKAGE_VERSION }}.autonomi.x86_64-unknown-linux-musl.deb"
            echo "\`\`\`"
            echo ""
            echo "The binaries will be installed to \`/usr/local/bin\`."
            echo ""
            echo "Verify the installation:"
            echo "\`\`\`bash"
            echo "ant --version"
            echo "antnode --version"
            echo "antctl --version"
            echo "\`\`\`"
            echo ""
            echo "### Linux CLI Suite (Fedora/RHEL/CentOS)"
            echo ""
            echo "Install \`ant\`, \`antnode\`, and \`antctl\` using the signed rpm package."
            echo ""
            echo "Download the appropriate rpm file for your architecture:"
            echo "- **x86_64:** \`${{ env.PACKAGE_VERSION }}.autonomi.x86_64-unknown-linux-musl.rpm\`"
            echo "- **ARM64 (aarch64):** \`${{ env.PACKAGE_VERSION }}.autonomi.aarch64-unknown-linux-musl.rpm\`"
            echo "- **ARMv7:** \`${{ env.PACKAGE_VERSION }}.autonomi.armv7-unknown-linux-musleabihf.rpm\`"
            echo "- **ARM:** \`${{ env.PACKAGE_VERSION }}.autonomi.arm-unknown-linux-musleabi.rpm\`"
            echo ""
            echo "**Import the GPG signing key (first time only):**"
            echo "\`\`\`bash"
            echo "curl -fsSL https://github.com/maidsafe/autonomi/raw/main/resources/keys/autonomi-signing-key.asc | sudo rpm --import -"
            echo "\`\`\`"
            echo ""
            echo "**Install the package:**"
            echo "\`\`\`bash"
            echo "sudo rpm -i ${{ env.PACKAGE_VERSION }}.autonomi.x86_64-unknown-linux-musl.rpm"
            echo "\`\`\`"
            echo ""
            echo "Or using dnf:"
            echo "\`\`\`bash"
            echo "sudo dnf install ./${{ env.PACKAGE_VERSION }}.autonomi.x86_64-unknown-linux-musl.rpm"
            echo "\`\`\`"
            echo ""
            echo "**Verify the signature (optional):**"
            echo "\`\`\`bash"
            echo "rpm --checksig ${{ env.PACKAGE_VERSION }}.autonomi.x86_64-unknown-linux-musl.rpm"
            echo "\`\`\`"
            echo ""
            echo "The binaries will be installed to \`/usr/local/bin\`."
            echo ""
            echo "Verify the installation:"
            echo "\`\`\`bash"
            echo "ant --version"
            echo "antnode --version"
            echo "antctl --version"
            echo "\`\`\`"
          } > release-description.md

      # For the next two steps, it seems to be necessary to set `GITHUB_TOKEN` on the step rather
      # than the job level.
      - name: create release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.AUTONOMI_PAT }}
        with:
          tag_name: ${{ env.RELEASE_PREFIX }}-${{ env.PACKAGE_VERSION }}
          release_name: ${{ env.PACKAGE_VERSION }}
          draft: false
          prerelease: ${{ startsWith(github.ref, 'refs/heads/rc') && true || false }}
          body_path: release-description.md

      - name: upload artifacts as assets
        env:
          GITHUB_TOKEN: ${{ secrets.AUTONOMI_PAT }}
        shell: bash
        run: |
          (
            cd packaged_architectures
            ls | xargs gh release upload ${{ env.RELEASE_PREFIX }}-${{ env.PACKAGE_VERSION }}
          )

      - name: upload macOS pkg installers
        env:
          GITHUB_TOKEN: ${{ secrets.AUTONOMI_PAT }}
        shell: bash
        run: |
          echo "Uploading macOS pkg installers..."
          for pkg in pkg-artifacts/*.pkg; do
            if [ -f "$pkg" ]; then
              echo "Uploading $pkg"
              gh release upload ${{ env.RELEASE_PREFIX }}-${{ env.PACKAGE_VERSION }} "$pkg"
            fi
          done

      - name: upload macOS Node Launchpad DMGs
        env:
          GITHUB_TOKEN: ${{ secrets.AUTONOMI_PAT }}
        shell: bash
        run: |
          echo "Uploading macOS Node Launchpad DMGs..."
          for dmg in dmg-artifacts/*.dmg; do
            if [ -f "$dmg" ]; then
              echo "Uploading $dmg"
              gh release upload ${{ env.RELEASE_PREFIX }}-${{ env.PACKAGE_VERSION }} "$dmg"
            fi
          done

      - name: upload Windows MSI installer
        env:
          GITHUB_TOKEN: ${{ secrets.AUTONOMI_PAT }}
        shell: bash
        run: |
          echo "Uploading Windows MSI installer..."
          for msi in msi-artifacts/*.msi; do
            if [ -f "$msi" ]; then
              echo "Uploading $msi"
              gh release upload ${{ env.RELEASE_PREFIX }}-${{ env.PACKAGE_VERSION }} "$msi"
            fi
          done

      - name: upload Windows MSIX installer
        env:
          GITHUB_TOKEN: ${{ secrets.AUTONOMI_PAT }}
        shell: bash
        run: |
          echo "Uploading Windows MSIX installer..."
          for file in msix-artifacts/*; do
            if [ -f "$file" ]; then
              echo "Uploading $file"
              gh release upload ${{ env.RELEASE_PREFIX }}-${{ env.PACKAGE_VERSION }} "$file"
            fi
          done

      - name: upload Linux deb packages
        env:
          GITHUB_TOKEN: ${{ secrets.AUTONOMI_PAT }}
        shell: bash
        run: |
          echo "Uploading Linux deb packages..."
          for file in deb-artifacts/*; do
            if [ -f "$file" ]; then
              echo "Uploading $file"
              gh release upload ${{ env.RELEASE_PREFIX }}-${{ env.PACKAGE_VERSION }} "$file"
            fi
          done

      - name: upload Linux rpm packages
        env:
          GITHUB_TOKEN: ${{ secrets.AUTONOMI_PAT }}
        shell: bash
        run: |
          echo "Uploading Linux rpm packages..."
          for file in rpm-artifacts/*; do
            if [ -f "$file" ]; then
              echo "Uploading $file"
              gh release upload ${{ env.RELEASE_PREFIX }}-${{ env.PACKAGE_VERSION }} "$file"
            fi
          done

  # publish-crates:
  #   if: ${{ github.repository_owner == 'maidsafe' && github.ref == 'refs/heads/stable' }}
  #   needs: [ build, s3-release ]
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/checkout@v6
  #       with:
  #         fetch-depth: "0"
  #         token: ${{ secrets.AUTONOMI_PAT }}
  #     - uses: dtolnay/rust-toolchain@stable
  #
  #     # Required for the creation of tags
  #     - shell: bash
  #       run: |
  #         git config --local user.email "action@github.com"
  #         git config --local user.name "GitHub Action"
  #
  #     - uses: cargo-bins/cargo-binstall@main
  #     - shell: bash
  #       run: cargo binstall --no-confirm release-plz
  #
  #     - name: publish crates
  #       shell: bash
  #       run: |
  #         cargo login "${{ secrets.CRATES_IO_TOKEN }}"
  #         # The use of 'awk' suppresses the annoying instrumentation output that makes the log
  #         # difficult to read.
  #         release-plz release --git-token ${{ secrets.AUTONOMI_PAT }} | \
  #           awk '{ if (!/^\s*in release with input/ && !/^\s{4}/) print }'
