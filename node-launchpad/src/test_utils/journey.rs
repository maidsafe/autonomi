// Copyright 2025 MaidSafe.net limited.
//
// This SAFE Network Software is licensed to you under The General Public License (GPL), version 3.
// Unless required by applicable law or agreed to in writing, the SAFE Network Software distributed
// under the GPL Licence is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. Please review the Licences for the specific language governing
// permissions and limitations relating to use of the SAFE Network Software.

use super::{keyboard::KeySequence, mock_registry::MockNodeRegistry, test_helpers::TestAppBuilder};
use crate::{app::App, mode::Scene, runtime::TestRuntime};
use color_eyre::Result;
use crossterm::event::KeyEvent;
use std::time::Duration;

pub struct Journey {
    pub name: String,
    pub steps: Vec<JourneyStep>,
    app: App,
    test_runtime: TestRuntime,
}

#[derive(Debug, Clone)]
pub struct JourneyStep {
    pub keys: Vec<KeyEvent>,
    pub expected_scene: Option<Scene>,
    pub assertions: Vec<ScreenAssertion>,
}

#[derive(Debug, Clone)]
pub enum ScreenAssertion {
    ExactScreen(Vec<String>),
    ContainsText(String),
}

impl Journey {
    pub fn new(name: String, mut app: App) -> Result<Self> {
        let test_runtime = TestRuntime::new_simple(160, 30)?;

        use tokio::sync::mpsc;
        let (action_tx, mut action_rx) = mpsc::unbounded_channel();
        let rect = ratatui::prelude::Rect::new(0, 0, 160, 30);

        // Ensure components are fully initialized before sending any actions
        app.init_components(rect, action_tx.clone())?;

        // Only send initial tick after all components are ready
        action_tx.send(crate::action::Action::Tick)?;

        // Process any initial actions generated by component initialization
        let mut processed_count = 0;
        const MAX_INITIAL_ACTIONS: usize = 100; // Prevent infinite loops

        while let Ok(action) = action_rx.try_recv() {
            if processed_count >= MAX_INITIAL_ACTIONS {
                error!("Max initial actions reached, we're breaking early.");
                break;
            }
            app.process_action(action.clone(), &action_tx)?;
            processed_count += 1;
        }

        Ok(Self {
            name,
            steps: Vec::new(),
            app,
            test_runtime,
        })
    }

    pub fn add_step(&mut self, step: JourneyStep) {
        self.steps.push(step);
    }

    pub async fn run(&mut self) -> Result<()> {
        // Convert journey steps to test script
        let script = self.build_test_script();
        self.test_runtime.set_script(script);

        // Actually run the app with the scripted test runtime!
        // This is the key: we use the SAME App::run_with_runtime as production
        self.app.run_with_runtime(&mut self.test_runtime).await?;

        Ok(())
    }

    fn build_test_script(&self) -> Vec<crate::runtime::TestStep> {
        let mut script = Vec::new();

        for step in self.steps.iter() {
            // Add key events
            for key in &step.keys {
                script.push(crate::runtime::TestStep::InjectKey(*key));
            }

            // Add scene expectation if present
            if let Some(expected_scene) = step.expected_scene {
                script.push(crate::runtime::TestStep::ExpectScene(expected_scene));
            }

            // Add screen assertions
            for assertion in &step.assertions {
                match assertion {
                    ScreenAssertion::ExactScreen(lines) => {
                        script.push(crate::runtime::TestStep::ExactScreen(lines.clone()));
                    }
                    ScreenAssertion::ContainsText(text) => {
                        script.push(crate::runtime::TestStep::ExpectText(text.clone()));
                    }
                }
            }

            // Add a small wait between steps
            script.push(crate::runtime::TestStep::Wait(Duration::from_millis(50)));
        }

        // Add exit at the end to terminate the test properly
        script.push(crate::runtime::TestStep::Exit);

        script
    }
}

pub struct JourneyBuilder {
    journey: Journey,
    current_step: Option<JourneyStep>,
    mock_registry: Option<MockNodeRegistry>,
}

impl JourneyBuilder {
    pub async fn new(name: &str) -> Result<Self> {
        let registry = MockNodeRegistry::empty()?;
        let (app, registry) = TestAppBuilder::new()
            .with_mock_registry(registry)
            .build()
            .await?;

        Ok(Self {
            journey: Journey::new(name.to_string(), app)?,
            current_step: None,
            mock_registry: Some(registry),
        })
    }

    pub async fn new_with_nodes(name: &str, node_count: u64) -> Result<Self> {
        let registry = if node_count > 0 {
            MockNodeRegistry::with_nodes(node_count)?
        } else {
            MockNodeRegistry::empty()?
        };

        let (app, registry) = TestAppBuilder::new()
            .with_mock_registry(registry)
            .build()
            .await?;

        Ok(Self {
            journey: Journey::new(name.to_string(), app)?,
            current_step: None,
            mock_registry: Some(registry),
        })
    }

    pub async fn new_with_registry(name: &str, registry: MockNodeRegistry) -> Result<Self> {
        let (app, registry) = TestAppBuilder::new()
            .with_mock_registry(registry)
            .build()
            .await?;

        Ok(Self {
            journey: Journey::new(name.to_string(), app)?,
            current_step: None,
            mock_registry: Some(registry),
        })
    }

    pub fn start_from(mut self, scene: Scene) -> Self {
        self.journey.app.scene = scene;
        self
    }

    pub fn press(mut self, keys: impl Into<KeySequence>) -> Self {
        let key_sequence: KeySequence = keys.into();
        let key_events = key_sequence.build();

        if let Some(ref mut step) = self.current_step {
            step.keys.extend(key_events);
        } else {
            self.current_step = Some(JourneyStep {
                keys: key_events,
                expected_scene: None,
                assertions: Vec::new(),
            });
        }
        self
    }

    pub fn press_key(mut self, key: KeyEvent) -> Self {
        if let Some(ref mut step) = self.current_step {
            step.keys.push(key);
        } else {
            self.current_step = Some(JourneyStep {
                keys: vec![key],
                expected_scene: None,
                assertions: Vec::new(),
            });
        }
        self
    }

    pub fn expect_scene(mut self, scene: Scene) -> Self {
        if let Some(ref mut step) = self.current_step {
            step.expected_scene = Some(scene);
        } else {
            self.current_step = Some(JourneyStep {
                keys: Vec::new(),
                expected_scene: Some(scene),
                assertions: Vec::new(),
            });
        }
        self
    }

    pub fn expect_text(mut self, text: &str) -> Self {
        if let Some(ref mut step) = self.current_step {
            step.assertions
                .push(ScreenAssertion::ContainsText(text.to_string()));
        } else {
            self.current_step = Some(JourneyStep {
                keys: Vec::new(),
                expected_scene: None,
                assertions: vec![ScreenAssertion::ContainsText(text.to_string())],
            });
        }
        self
    }

    pub fn expect_screen(mut self, screen: &[&str]) -> Self {
        let screen_lines: Vec<String> = screen.iter().map(|s| s.to_string()).collect();

        if let Some(ref mut step) = self.current_step {
            step.assertions
                .push(ScreenAssertion::ExactScreen(screen_lines));
        } else {
            self.current_step = Some(JourneyStep {
                keys: Vec::new(),
                expected_scene: None,
                assertions: vec![ScreenAssertion::ExactScreen(screen_lines)],
            });
        }
        self
    }

    // Registry manipulation methods
    pub fn add_node_to_registry(
        mut self,
        node_data: ant_service_management::NodeServiceData,
    ) -> Result<Self> {
        if let Some(ref mut registry) = self.mock_registry {
            registry
                .add_node(node_data)
                .map_err(|e| color_eyre::eyre::eyre!("Failed to add node to registry: {e}"))?;
        }
        Ok(self)
    }

    pub fn remove_node_from_registry(mut self, service_name: &str) -> Result<Self> {
        if let Some(ref mut registry) = self.mock_registry {
            registry
                .remove_node(service_name)
                .map_err(|e| color_eyre::eyre::eyre!("Failed to remove node from registry: {e}"))?;
        }
        Ok(self)
    }

    pub fn update_registry_node_status(
        mut self,
        service_name: &str,
        status: ant_service_management::ServiceStatus,
    ) -> Result<Self> {
        if let Some(ref mut registry) = self.mock_registry {
            registry
                .update_node_status(service_name, status)
                .map_err(|e| color_eyre::eyre::eyre!("Failed to update node status: {e}"))?;
        }
        Ok(self)
    }

    pub fn reset_registry(mut self) -> Result<Self> {
        if let Some(ref mut registry) = self.mock_registry {
            registry
                .reset_all()
                .map_err(|e| color_eyre::eyre::eyre!("Failed to reset registry: {e}"))?;
        }
        Ok(self)
    }

    // Registry assertions
    pub fn expect_registry_contains(self, service_name: &str) -> Result<Self> {
        if let Some(ref registry) = self.mock_registry
            && !registry.contains_node(service_name)
        {
            return Err(color_eyre::eyre::eyre!(
                "Registry does not contain expected node: {service_name}"
            ));
        }
        Ok(self)
    }

    pub fn expect_registry_not_contains(self, service_name: &str) -> Result<Self> {
        if let Some(ref registry) = self.mock_registry
            && registry.contains_node(service_name)
        {
            return Err(color_eyre::eyre::eyre!(
                "Registry unexpectedly contains node: {service_name}"
            ));
        }
        Ok(self)
    }

    pub fn expect_registry_node_status(
        self,
        service_name: &str,
        status: ant_service_management::ServiceStatus,
    ) -> Result<Self> {
        if let Some(ref registry) = self.mock_registry
            && !registry.verify_node_status(service_name, status.clone())
        {
            return Err(color_eyre::eyre::eyre!(
                "Registry node {service_name} does not have expected status: {status:?}"
            ));
        }
        Ok(self)
    }

    pub fn expect_node_count_in_registry(self, count: u64) -> Result<Self> {
        if let Some(ref registry) = self.mock_registry
            && registry.node_count() != count
        {
            return Err(color_eyre::eyre::eyre!(
                "Registry has {} nodes, expected {count}",
                registry.node_count()
            ));
        }
        Ok(self)
    }

    pub fn expect_registry_is_empty(self) -> Result<Self> {
        self.expect_node_count_in_registry(0)
    }

    pub fn step(mut self) -> Self {
        if let Some(step) = self.current_step.take() {
            self.journey.add_step(step);
        }
        self
    }

    pub async fn run(mut self) -> Result<()> {
        if let Some(step) = self.current_step.take() {
            self.journey.add_step(step);
        }

        self.journey.run().await
    }

    pub fn build(mut self) -> Result<Journey> {
        if let Some(step) = self.current_step.take() {
            self.journey.add_step(step);
        }

        Ok(self.journey)
    }
}

impl From<char> for KeySequence {
    fn from(c: char) -> Self {
        KeySequence::new().key(c)
    }
}
