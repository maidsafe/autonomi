// Copyright 2025 MaidSafe.net limited.
//
// This SAFE Network Software is licensed to you under The General Public License (GPL), version 3.
// Unless required by applicable law or agreed to in writing, the SAFE Network Software distributed
// under the GPL Licence is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. Please review the Licences for the specific language governing
// permissions and limitations relating to use of the SAFE Network Software.

use super::{
    keyboard::KeySequence,
    mock_registry::MockNodeRegistry,
    test_helpers::{TestAppBuilder, buffer_to_lines},
};
use crate::{
    app::App,
    focus::FocusTarget,
    mode::{InputMode, Scene},
    runtime::TestRuntime,
};
use color_eyre::{Result, eyre::eyre};
use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
use ratatui::buffer::Buffer;
use std::time::{Duration, Instant};

pub struct Journey {
    pub name: String,
    pub steps: Vec<JourneyStep>,
    app: App,
    test_runtime: TestRuntime,
}

#[derive(Debug, Clone)]
pub struct JourneyStep {
    pub keys: Vec<KeyEvent>,
    pub expected_scene: Option<Scene>,
    pub assertions: Vec<ScreenAssertion>,
}

#[derive(Debug, Clone)]
pub enum ScreenAssertion {
    ExactScreen(Vec<String>),
    ContainsText(String),
    SceneIs(Scene),
}

impl Journey {
    pub fn new(name: String, mut app: App) -> Result<Self> {
        let test_runtime = TestRuntime::new_simple(160, 30)?;

        use tokio::sync::mpsc;
        let (action_tx, mut action_rx) = mpsc::unbounded_channel();
        let rect = ratatui::prelude::Rect::new(0, 0, 160, 30);

        // Ensure components are fully initialized before sending any actions
        app.init_components(rect, action_tx.clone())?;

        // Only send initial tick after all components are ready
        action_tx.send(crate::action::Action::Tick)?;

        // Process any initial actions generated by component initialization
        let mut processed_count = 0;
        const MAX_INITIAL_ACTIONS: usize = 100; // Prevent infinite loops

        while let Ok(action) = action_rx.try_recv() {
            if processed_count >= MAX_INITIAL_ACTIONS {
                error!("Max initial actions reached, we're breaking early.");
                break;
            }
            app.process_action(action.clone(), &action_tx)?;
            processed_count += 1;
        }

        Ok(Self {
            name,
            steps: Vec::new(),
            app,
            test_runtime,
        })
    }

    pub fn add_step(&mut self, step: JourneyStep) {
        self.steps.push(step);
    }

    pub async fn run(&mut self) -> Result<()> {
        println!("Journey '{}': Starting execution", self.name);

        // Convert journey steps to test script
        let script = self.build_test_script();
        self.test_runtime.set_script(script);

        // Actually run the app with the scripted test runtime!
        // This is the key: we use the SAME App::run_with_runtime as production
        self.app.run_with_runtime(&mut self.test_runtime).await?;

        println!("Journey '{}': Completed successfully", self.name);
        Ok(())
    }

    fn build_test_script(&self) -> Vec<crate::runtime::TestStep> {
        let mut script = Vec::new();

        for (step_index, step) in self.steps.iter().enumerate() {
            println!("Journey '{}': Building step {}", self.name, step_index + 1);

            // Add key events
            for key in &step.keys {
                script.push(crate::runtime::TestStep::InjectKey(*key));
            }

            // Add scene expectation if present
            if let Some(expected_scene) = step.expected_scene {
                script.push(crate::runtime::TestStep::ExpectScene(expected_scene));
            }

            // Add screen assertions
            for assertion in &step.assertions {
                match assertion {
                    ScreenAssertion::ExactScreen(lines) => {
                        script.push(crate::runtime::TestStep::ExactScreen(lines.clone()));
                    }
                    ScreenAssertion::ContainsText(text) => {
                        script.push(crate::runtime::TestStep::ExpectText(text.clone()));
                    }
                    ScreenAssertion::SceneIs(scene) => {
                        script.push(crate::runtime::TestStep::ExpectScene(*scene));
                    }
                }
            }

            // Add a small wait between steps
            script.push(crate::runtime::TestStep::Wait(Duration::from_millis(50)));
        }

        // Add exit at the end to terminate the test properly
        script.push(crate::runtime::TestStep::Exit);

        script
    }

    pub fn render_screen(&mut self) -> Result<Buffer> {
        // Simply return the last captured frame from the runtime
        if let Some(buffer) = self.test_runtime.get_last_frame() {
            Ok(buffer.clone())
        } else {
            Err(eyre!("No frames captured yet"))
        }
    }

    pub fn assert_current_screen(&mut self, assertion: &ScreenAssertion) -> Result<()> {
        let buffer = self.render_screen()?;
        let screen_lines = buffer_to_lines(&buffer);

        match assertion {
            ScreenAssertion::ExactScreen(expected_lines) => {
                if screen_lines.len() != expected_lines.len() {
                    return Err(eyre!(
                        "Screen has {} lines, expected {}",
                        screen_lines.len(),
                        expected_lines.len()
                    ));
                }

                for (i, (actual, expected)) in
                    screen_lines.iter().zip(expected_lines.iter()).enumerate()
                {
                    if actual != expected {
                        return Err(eyre!(
                            "Line {} mismatch:\n  Actual:   '{}'\n  Expected: '{}'",
                            i + 1,
                            actual,
                            expected
                        ));
                    }
                }
            }
            ScreenAssertion::ContainsText(text) => {
                let found = screen_lines.iter().any(|line| line.contains(text));
                if !found {
                    return Err(eyre!("Screen does not contain text: '{}'", text));
                }
            }
            ScreenAssertion::SceneIs(expected_scene) => {
                if self.app.scene != *expected_scene {
                    return Err(eyre!(
                        "Expected scene {:?}, got {:?}",
                        expected_scene,
                        self.app.scene
                    ));
                }
            }
        }

        Ok(())
    }

    pub fn switch_to_input_mode(&mut self) {
        self.app.input_mode = InputMode::Entry;
    }

    pub fn switch_to_navigation_mode(&mut self) {
        self.app.input_mode = InputMode::Navigation;
    }

    pub fn focus_component(&mut self, target: FocusTarget) -> Result<()> {
        self.app.focus_manager.set_focus(target)?;
        Ok(())
    }

    pub fn enter_text(&mut self, text: &str) {
        if self.app.input_mode != InputMode::Entry {
            self.switch_to_input_mode();
        }

        // Queue character events instead of running a new loop
        for c in text.chars() {
            let key = KeyEvent::new(KeyCode::Char(c), KeyModifiers::empty());
            self.test_runtime.queue_event(crate::tui::Event::Key(key));
        }
    }

    pub fn press_and_process(&mut self, key: KeyEvent) {
        // Queue single key event instead of running a new loop
        self.test_runtime.queue_event(crate::tui::Event::Key(key));
    }

    pub fn stop_test(&mut self) {
        // Queue quit event to stop the single event loop
        self.test_runtime.queue_event(crate::tui::Event::Quit);
    }

    pub async fn wait_for_scene(&mut self, scene: Scene, timeout_ms: u64) -> Result<()> {
        if self.app.scene != scene {
            let start = Instant::now();
            let timeout_duration = Duration::from_millis(timeout_ms);

            loop {
                if self.app.scene == scene {
                    break;
                }
                if start.elapsed() > timeout_duration {
                    return Err(eyre!(
                        "Timeout waiting for scene {:?}, current scene is {:?}",
                        scene,
                        self.app.scene
                    ));
                }
                tokio::time::sleep(Duration::from_millis(10)).await;
            }
        }

        Ok(())
    }
}

pub struct JourneyBuilder {
    journey: Journey,
    current_step: Option<JourneyStep>,
    mock_registry: Option<MockNodeRegistry>,
}

impl JourneyBuilder {
    pub async fn new(name: &str) -> Result<Self> {
        let registry = MockNodeRegistry::empty()?;
        let (app, registry) = TestAppBuilder::new()
            .with_mock_registry(registry)
            .build()
            .await?;

        Ok(Self {
            journey: Journey::new(name.to_string(), app)?,
            current_step: None,
            mock_registry: Some(registry),
        })
    }

    pub async fn new_with_nodes(name: &str, node_count: u64) -> Result<Self> {
        let registry = if node_count > 0 {
            MockNodeRegistry::with_nodes(node_count)?
        } else {
            MockNodeRegistry::empty()?
        };

        let (app, registry) = TestAppBuilder::new()
            .with_mock_registry(registry)
            .build()
            .await?;

        Ok(Self {
            journey: Journey::new(name.to_string(), app)?,
            current_step: None,
            mock_registry: Some(registry),
        })
    }

    pub async fn new_with_registry(name: &str, registry: MockNodeRegistry) -> Result<Self> {
        let (app, registry) = TestAppBuilder::new()
            .with_mock_registry(registry)
            .build()
            .await?;

        Ok(Self {
            journey: Journey::new(name.to_string(), app)?,
            current_step: None,
            mock_registry: Some(registry),
        })
    }

    pub fn start_from(mut self, scene: Scene) -> Self {
        self.journey.app.scene = scene;
        self
    }

    pub fn press(mut self, keys: impl Into<KeySequence>) -> Self {
        let key_sequence: KeySequence = keys.into();
        let key_events = key_sequence.build();

        if let Some(ref mut step) = self.current_step {
            step.keys.extend(key_events);
        } else {
            self.current_step = Some(JourneyStep {
                keys: key_events,
                expected_scene: None,
                assertions: Vec::new(),
            });
        }
        self
    }

    pub fn press_key(mut self, key: KeyEvent) -> Self {
        if let Some(ref mut step) = self.current_step {
            step.keys.push(key);
        } else {
            self.current_step = Some(JourneyStep {
                keys: vec![key],
                expected_scene: None,
                assertions: Vec::new(),
            });
        }
        self
    }

    pub fn expect_scene(mut self, scene: Scene) -> Self {
        if let Some(ref mut step) = self.current_step {
            step.expected_scene = Some(scene);
        } else {
            self.current_step = Some(JourneyStep {
                keys: Vec::new(),
                expected_scene: Some(scene),
                assertions: Vec::new(),
            });
        }
        self
    }

    pub fn expect_text(mut self, text: &str) -> Self {
        if let Some(ref mut step) = self.current_step {
            step.assertions
                .push(ScreenAssertion::ContainsText(text.to_string()));
        } else {
            self.current_step = Some(JourneyStep {
                keys: Vec::new(),
                expected_scene: None,
                assertions: vec![ScreenAssertion::ContainsText(text.to_string())],
            });
        }
        self
    }

    pub fn expect_screen(mut self, screen: &[&str]) -> Self {
        let screen_lines: Vec<String> = screen.iter().map(|s| s.to_string()).collect();

        if let Some(ref mut step) = self.current_step {
            step.assertions
                .push(ScreenAssertion::ExactScreen(screen_lines));
        } else {
            self.current_step = Some(JourneyStep {
                keys: Vec::new(),
                expected_scene: None,
                assertions: vec![ScreenAssertion::ExactScreen(screen_lines)],
            });
        }
        self
    }

    // Registry manipulation methods
    pub fn add_node_to_registry(
        mut self,
        node_data: ant_service_management::NodeServiceData,
    ) -> Result<Self> {
        if let Some(ref mut registry) = self.mock_registry {
            registry
                .add_node(node_data)
                .map_err(|e| color_eyre::eyre::eyre!("Failed to add node to registry: {e}"))?;
        }
        Ok(self)
    }

    pub fn remove_node_from_registry(mut self, service_name: &str) -> Result<Self> {
        if let Some(ref mut registry) = self.mock_registry {
            registry
                .remove_node(service_name)
                .map_err(|e| color_eyre::eyre::eyre!("Failed to remove node from registry: {e}"))?;
        }
        Ok(self)
    }

    pub fn update_registry_node_status(
        mut self,
        service_name: &str,
        status: ant_service_management::ServiceStatus,
    ) -> Result<Self> {
        if let Some(ref mut registry) = self.mock_registry {
            registry
                .update_node_status(service_name, status)
                .map_err(|e| color_eyre::eyre::eyre!("Failed to update node status: {e}"))?;
        }
        Ok(self)
    }

    pub fn reset_registry(mut self) -> Result<Self> {
        if let Some(ref mut registry) = self.mock_registry {
            registry
                .reset_all()
                .map_err(|e| color_eyre::eyre::eyre!("Failed to reset registry: {e}"))?;
        }
        Ok(self)
    }

    // Registry assertions
    pub fn expect_registry_contains(self, service_name: &str) -> Result<Self> {
        if let Some(ref registry) = self.mock_registry
            && !registry.contains_node(service_name)
        {
            return Err(color_eyre::eyre::eyre!(
                "Registry does not contain expected node: {service_name}"
            ));
        }
        Ok(self)
    }

    pub fn expect_registry_not_contains(self, service_name: &str) -> Result<Self> {
        if let Some(ref registry) = self.mock_registry
            && registry.contains_node(service_name)
        {
            return Err(color_eyre::eyre::eyre!(
                "Registry unexpectedly contains node: {service_name}"
            ));
        }
        Ok(self)
    }

    pub fn expect_registry_node_status(
        self,
        service_name: &str,
        status: ant_service_management::ServiceStatus,
    ) -> Result<Self> {
        if let Some(ref registry) = self.mock_registry
            && !registry.verify_node_status(service_name, status.clone())
        {
            return Err(color_eyre::eyre::eyre!(
                "Registry node {service_name} does not have expected status: {status:?}"
            ));
        }
        Ok(self)
    }

    pub fn expect_node_count_in_registry(self, count: u64) -> Result<Self> {
        if let Some(ref registry) = self.mock_registry
            && registry.node_count() != count
        {
            return Err(color_eyre::eyre::eyre!(
                "Registry has {} nodes, expected {count}",
                registry.node_count()
            ));
        }
        Ok(self)
    }

    pub fn expect_registry_is_empty(self) -> Result<Self> {
        self.expect_node_count_in_registry(0)
    }

    pub fn step(mut self) -> Self {
        if let Some(step) = self.current_step.take() {
            self.journey.add_step(step);
        }
        self
    }

    pub async fn run(mut self) -> Result<()> {
        if let Some(step) = self.current_step.take() {
            self.journey.add_step(step);
        }

        self.journey.run().await
    }

    pub fn build(mut self) -> Result<Journey> {
        if let Some(step) = self.current_step.take() {
            self.journey.add_step(step);
        }

        Ok(self.journey)
    }
}

impl From<char> for KeySequence {
    fn from(c: char) -> Self {
        KeySequence::new().key(c)
    }
}

impl From<KeyEvent> for KeySequence {
    fn from(key: KeyEvent) -> Self {
        KeySequence::new().push_event(key)
    }
}

impl From<&str> for KeySequence {
    fn from(s: &str) -> Self {
        KeySequence::new().string(s)
    }
}

impl From<Vec<KeyEvent>> for KeySequence {
    fn from(events: Vec<KeyEvent>) -> Self {
        let mut seq = KeySequence::new();
        for event in events {
            seq = seq.push_event(event);
        }
        seq
    }
}
